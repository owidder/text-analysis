Performance-Testing with 20 users concurrently creating/editing/deleting elements causes the server to not respond	Using JMeter and the performance-test file in the repository, the server will swiftly stop responding. Testing on the integration server indicates that a deadlock is likely the cause, since response time and number of requests settle at 0, however there is no progress in the test plan.		Bug	iteraplan PO	09/Jul/13 10:50 AM	10/Sep/13 3:58 PM					load-test	performance								"16/Jul/13 2:08 PM;svo;This is aparently a deadlock caused by hibernate/dbcp, if there are more threads reading and writing than the given maxConnections (which is 8 per default). It is possible that a thread that is currently not connected holds the lock on the {{TableGenerator}}. This causes connected threads to block on this object. If the number of blocked threads reaches the configured number of maximum connections, the thread actually holding the lock on this object will not be able to get a connection and wait in {{GenericObjectPool#borrowObject}} until one of the connected threads closes their connection- in this case, for ever. 
This might be related to this problem: http://stackoverflow.com/questions/5714511/deadlock-issue-in-dbcp-deployed-on-tomcat
There appears to be no issue on the hibernate or dbcp bug trackers that directly relates to this bug. 
The core of the problem here seems to be in {{AbstractSaveEventListener#saveWithGeneratedId}}, line 121: the lock on the {{TableGenerator}} is acquired here by entering the synchronized method {{TableGenerator#generate}}, however, the connection is supposed to be established later."	16/Jul/13 4:46 PM;svo;Does not seem to be fixed with Hibernate 4 either, although only changelogs since version 4.1.11 are available.	"18/Jul/13 2:26 PM;svo;Problem can be avoided using a workaround: since we cannot fix/patch the system, we have to ensure that there are always more connections available than threads working on tomcat. The number of maximum active threads for a certain connection is defined in the appropriate connector in the {{server.xml}}. Changing the attribute {{maxThreads}} (and the associated attributes {{minSpareThreads}} and {{maxSpareThreads}})to a value lower than {{database.pool.maxActive}} defined in {{iteraplan_db.properties}} fixes this issue.
The template for {{iteraplan_db.properties}} has been updated so that the default value for {{database.pool.maxActive}} is 21, and the configuration guide for the upcoming release as well as the developer guide now include instructions to change the tomcat configuration accordingly to allow a maximum number of working threads of 20 for the used protocols.
These values can be changed as required, but you have to make sure that the value {{database.pool.maxActive}} is always greater than the maximum number of threads."	18/Jul/13 3:34 PM;svo;verified with a test using jmeter with 40 users with the given setting. a maximum of 20 threads were processing the requests on tomcat and the test case ran fine (slow, but they didn't deadlock). In comparison, a test with 40 users but without appropriate thread limit quickly causes the described deadlock 	"18/Jul/13 3:35 PM;svo;Better solution: use a thread pool instead. This ensures that even if the connections use different protocols, the total maximum of threads does not exceed the ""thread limit"".
Updated the user guide accordingly, see: http://www.iteraplan.de/wiki/display/upcomingIteraplan/Tomcat+Configuration"	18/Jul/13 3:44 PM;svo;The recommended settings are now added to the developer guide: https://iteraweb.iteratec.de/confluence/display/iwiki/Developer+Guide+for+3.x	18/Jul/13 4:48 PM;svo;Remark for whoever will test this: I would recommended using a directly accessible system as a server (LT091 is set up for this task) and have JConsole monitoring tomcat.	"18/Jul/13 10:57 PM;sry;Wow, excellent work!!

If nothing else needs to be done, pls forward to next tieckt state."	"10/Sep/13 3:58 PM;gph;(/) I could reproduce the problem and the workaround on a local iteraplan instance.

(/) There is no deadlock, when ""maxThreads"" and ""maxSpareThreads"" parameters in the Tomcat configuration are equal or lower than the ""maxActive"" and ""maxIdle"" parameters for the db pool.

(!) This is not a real ""solution"", but only a workaround. It is not evident, if a solution would be possible, because the deadlock happens in Hibernate code. Maybe by configuration?

(!) The workaround is only valid for a single-instance Tomcat. When more webapps (iteraplan or others) are deployed, the right value for ""max(Spare)Threads"" is more difficult to determine.

There are four cases:
1,) single instance of iteraplan
2.) single instance of iteraplan and other webapp(s)
3.) multiple instances of iteraplan
4.) multiple instances of iteraplan and other webapp(s)

For these cases it should be clarified, how the parameters have to be set. The results should be included in the documentation.
"	12/Sep/13 12:28 PM;svo;See also: ITERAPLAN-1773, which would be the ticket for the actual solution																																													
