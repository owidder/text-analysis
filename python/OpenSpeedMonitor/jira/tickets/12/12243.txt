Asynchronen Eventhandler implementieren	"Der bei der Persistierung neuer EventResults angestoßene Prozess dauert inzwischen zu lange. Es wird nach Graphite berichtet, es werden MeasuredValues berechnet und markiert, es werden hars geparst und WebPerformanceWaterfalls persistiert. Dadurch, dass der Prozess so langwierig geworden ist bekommen wir zunehmend  folgendes:
{code}
org.hibernate.StaleObjectStateException: Row was updated or deleted by another transaction (or unsaved-value mapping was incorrect): [de.iteratec.ism.chart.MeasuredValue#1325093]
  at org.grails.datastore.gorm.GormStaticApi$_methodMissing_closure2.doCall(GormStaticApi.groovy:102)
  at de.iteratec.isocsi.PageMeasuredValueService.ensurePresence(PageMeasuredValueService.groovy:264)
  at de.iteratec.isocsi.PageMeasuredValueService.ensurePresenceAndCalculation(PageMeasuredValueService.groovy:251)
  at de.iteratec.isocsi.PageMeasuredValueService$_getOrCalculatePageMvs_closure4_closure7.doCall(PageMeasuredValueService.groovy:210)  
  at de.iteratec.isocsi.PageMeasuredValueService$_getOrCalculatePageMvs_closure4.doCall(PageMeasuredValueService.groovy:207)
  at de.iteratec.isocsi.PageMeasuredValueService.getOrCalculatePageMvs(PageMeasuredValueService.groovy:205)
  at de.iteratec.isocsi.PageMeasuredValueService.getOrCalculatePageMeasuredValues(PageMeasuredValueService.groovy:192)
  at de.iteratec.isocsi.CustomerSatisfactionHighChartService.getCalculatedPageMeasuredValuesAsHighChartMap(CustomerSatisfactionHighChartService.groovy:102)
  at de.iteratec.isocsi.CsiDashboardController.fillWithPageValuesAsHighChartMap(CsiDashboardController.groovy:339)
  at de.iteratec.isocsi.CsiDashboardController.fillWithAproximatgeMeasuredValueData(CsiDashboardController.groovy:299)
  at de.iteratec.isocsi.CsiDashboardController.showAll(CsiDashboardController.groovy:252)
  at com.googlecode.psiprobe.Tomcat70AgentValve.invoke(Tomcat70AgentValve.java:38)
  at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)
  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)
  at java.lang.Thread.run(Thread.java:724)
{code}

Wir sollten einen generischen EventHandler bauen und diesen hier einsetzen. An diesem können sich Services (wie z.B. der de.iteratec.ism.isreport.external.MetricReportingService) registrieren. Der Handler sorgt dann dafür, dass registrierte Services gerufen werden und deren Logik asynchron (in einem neuen Thread) abgearbeitet wird.

Zum Einsatz könnte z.B. folgendes kommen:
http://grails.org/doc/2.3.0.M1/guide/async.html  "		Improvement	OpenSpeedMonitor	15/May/14 10:50 AM	28/Sep/16 3:46 PM														"09/Jul/14 1:31 PM;nkuhn;Das Problem mit den org.hibernate.StaleObjectStateExceptions wird mit IT-393 gelöst.

Eine asynchrone Verarbeitung bleibt zwar aus Performance-Gründen wünschenswert, ist aber nicht mehr Prio A.

Mit einer Umsetzung mittels des folgenden Plugins wurde bereits begonnen:

http://grails.org/plugin/spring-events



Diese Arbeit steckt im Branch feature-async-processing. "	02/Sep/16 10:24 AM;nku;Wenn man dies umsetzen wollte könnte man jetzt den ResultPersisterService einfach asynchron machen.																																																					
