Hourly MeasuredValues für den 23. und 24.10.2013 nachberechnen	Auf Grund eines Bugs in Version 2.1.13 wurden die Hourly MeasuredValues für den 23. und 24.10.2013 nicht berechnet, diese müssen nachberechnet werden.		Bug	OpenSpeedMonitor	25/Oct/13 11:46 AM	25/Oct/13 1:36 PM														"25/Oct/13 1:21 PM;mzeimer;Code aus BootStrap.groovy (im iteraSpeedMonitor):

	EventMeasuredValueService eventMeasuredValueService;
	MeasuredValueUtilService measuredValueUtilService;
	JobResultService jobResultService;

	/**
	 * Recalculates missing measured values after bug of deployment at 23th Oct. 2013.
	 * 
	 * This bug was introduced in Version 2.1.13 and was fixed 2.1.14. This method was 
	 * added in 2.1.15 and should be removed in 2.1.16 after presence of measured 
	 * values has been verified. 
	 */
	private void updateMissingMeasuredValueOfOct23And24()
	{
		// DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute)
		DateTime oct23Start = new DateTime(2013, 10, 23, 0, 0, 0);
		DateTime oct24End = new DateTime(2013, 10, 24, 23, 59, 59);
		
		Collection<JobResult> jobResultsToCalculateFrom = jobResultService.findJobResultsByQueryParams(new MvQueryParams(), oct23Start.toDate(), oct24End.toDate());
		int countOfLeftJobResultsToCalcualteFrom = jobResultsToCalculateFrom.size();
		for(JobResult eachJobResultToCalculateFrom : jobResultsToCalculateFrom)
		{
			log.info 'Calculate missing measured value for JobResult with id: ' + eachJobResultToCalculateFrom.ident() + ', ' + countOfLeftJobResultsToCalcualteFrom + ' left to process';
			System.out.println('Calculate missing measured value for JobResult with id: ' + eachJobResultToCalculateFrom.ident() + ', ' + countOfLeftJobResultsToCalcualteFrom + ' left to process');
			
			DateTime testCompletion = new DateTime(eachJobResultToCalculateFrom.date);
			DateTime hourlyStart = measuredValueUtilService.resetToStartOfActualInterval(testCompletion, MeasuredValueInterval.HOURLY);
			
			for(EventResult eachEventResultToCalculateFrom : eachJobResultToCalculateFrom.getEventResults()) 
			{
				eventMeasuredValueService.createOrUpdateHourlyValue(hourlyStart, eachEventResultToCalculateFrom);
			}
			
			countOfLeftJobResultsToCalcualteFrom--;
		}
	}
"	"25/Oct/13 1:26 PM;mzeimer;Testlauf:

Kontroll-Query an MySQL:
    select aggregator_id,calculated,count(calculated),min(started), max(started) from measured_value where started < '2013-10-24 18:00:00' group by aggregator_id,calculated;

Dauer auf dem Architekturrechner (in der Eclipse-console, die etwas bremst):
Start: 11:55 Uhr
Ende: 13:14 Uhr
-> Dauer: ca. 1h 19m

Die Kontoll-Query lieferte vorher für den AggregatorType id ""1"" für max(started) den ""2013-10-23"" (Deployment-Tag) nun ""2013-10-24 17:00:00"" was soweit richtig ist. Dies hat das Problem auf meiner beseitigt. Die zuvor leere Anzeige im CSI Dashboard zeigt nun die passenden Daten (localhost):
http://localhost:8080/iteraSpeedMonitor/csiDashboard/showAll?_overwriteWarningAboutLongProcessingTime=&overwriteWarningAboutLongProcessingTime=on&_action_showAll=Yes%2C+I+want+to+proceed+even+if+it+takes+some+time&group=&from=23.10.2013&fromHour=12&fromMinute=48&to=25.10.2013&toHour=23&toMinute=59&aggrGroup=measuredEvent&selectedFolder=8&selectedFolder=3&selectedFolder=2&selectedFolder=7&selectedFolder=1&selectedFolder=5&selectedFolder=4&selectedFolder=6&selectedFolder=9&selectedPage=4&selectedPage=1&selectedPage=2&selectedPage=3&selectedPage=6&selectedPage=5&selectedPage=7&_selectedAllBrowsers=&selectedAllBrowsers=on&_selectedAllMeasuredEvents=&selectedAllMeasuredEvents=on&_selectedAllLocations=&selectedAllLocations=on

Während der Ausführung wird der Vorgang im log und in sysout (catalina.out) pro JobResult protokolliert in der Art:
""Calculate missing measured value for JobResult with id: 1723554, 1126 left to process"""																																																					
